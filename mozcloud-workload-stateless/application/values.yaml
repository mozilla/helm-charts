# Flag to enable / disable rendering of all templates this chart provides
enabled: true

#
# global
#
# app_code, chart, component_code, environment, and projectId should all be
# defined as global values in the parent Helm chart's values file(s) outside the
# scope of this Helm chart.
#
# For example:
#
#   # my-app/values.yaml
#   global:
#     mozcloud:
#       app_code: my-app                 # should match app_code in tenant file
#       chart: my-chart                  # the name of the chart
#       component_code: web              # should match component_code in tenant file
#
#   # my-app/values-dev.yaml
#   global:
#     mozcloud:
#       environment: dev                 # should match .Values.environment
#       projectId: moz-fx-my-app-nonprod # should match realms.<realm>.project_id in tenant file
#
# These are used to populate labels and metadata in MozCloud charts.
#

#
# ConfigMaps
#
# A dictionary of configMap definitions. Use this dictionary to define configMap
# resources. A configMap item should have at least a name and a data section.
#
# The top-level key should be the name and the configuration should be the
# value.
#
configMaps: {}
#  name:
#    # Argo CD settings
#    #
#    # See .Values.deployments.name.argo for details about how to configure this
#    # section.
#    #
#    # By default, configMaps will receive a syncWave value of -2.
#    #argo: {}
#    data:
#      foo: bar

#
# ExternalSecrets
#
# A dictionary of externalSecret definitions. An externalSecret should at least
# define a name. If you don't provide anything else, we expect this to default
# to reading from {{ .Values.global.environment }}-gke-app-secrets and writing
# to "mozcloud-workload-core-secrets.
#
# Each externalSecret should be a dictionary where the key is the name of the
# externalSecret and the value is its configuration.
#
externalSecrets: {}
#  name:
#    # Argo CD settings
#    #
#    # See .Values.deployments.name.argo for details about how to configure this
#    # section.
#    #
#    # By default, configMaps will receive a syncWave value of -2.
#    #argo: {}
#    target: my-target-k8s-secret
#    gsm:
#      secret: my-gsm-secret-to-read-from
#      version: my-gsm-secret-version-to-read-from


#
# ServiceAccounts
#
# A dictionary of serviceAccount definitions. A serviceAccount object has at least a
# name, additionally, a GCP Service Account to map to via annotations can
# be specified, too.
#
# Each serviceAccount should be a dictionary where the key is the name of the
# serviceAccount and the value is its configuration.
#
serviceAccounts: {}
#  name:
#    # Argo CD settings
#    #
#    # See .Values.deployments.name.argo for details about how to configure this
#    # section.
#    #
#    # By default, serviceAccounts will receive a syncWave value of -2.
#    #argo: {}
#    gcpServiceAccount:
#      name: unset
#      projectId: unset


#
# Deployments
#
# A dictionary of deployment definitions. A Deployment has a name and a list of
# containers.
#
# Each deployment should be a dictionary where the key is the name of the
# deployment and the value is its configuration.
#
deployments: {}
#  name:
#    # Argo CD settings
#    #argo:
#      # This configures the Argo hook deletion policies to apply to this
#      # resource.
#      #
#      # Options include:
#      #
#      #        HookSucceeded: The hook resource is deleted after the hook
#      #                       succeeded (e.g. job completed successfully).
#      #
#      #           HookFailed: The hook resource is deleted after the hook
#      #                       failed.
#      #
#      #   BeforeHookCreation: Hook resources are deleted before new ones are
#      #                       created. Do not use this if generateName is
#      #                       enabled.
#      #
#      # This should be configured as a comma-separated string (eg.
#      # "BeforeHookCreation,HookSucceeded"). Set to an empty string ("") to
#      # prevent the chart from creating any hook deletion policies.
#      #
#      # The default setting is: unset
#      #hookDeletionPolicy:
#
#      # Hooks (or resource hooks) allow you to specify at what point the
#      # resource should be created or updated relative to the application's
#      # sync operation in Argo CD. Hooks should be specified as a
#      # comma-separated string.
#      #
#      # Possible values:
#      #
#      #     PreSync*: Executes before the other manifests in the Helm chart.
#      #
#      #        Sync*: Executes at the same time as the other manifests in the
#      #               Helm chart.
#      #
#      #         Skip: Argo CD will skip this during the sync operation.
#      #
#      #    PostSync*: Executes after the other manifests in the Helm chart are
#      #               applied successfully.
#      #
#      #     SyncFail: Executes after a failed sync operation.
#      #
#      #   PostDelete: Executes after all resources in an Argo CD application
#      #               are deleted.
#      #
#      #   * The 3 sync phases commonly used when creating resource hooks.
#      #
#      # For example: to update a resource after every sync operation,
#      # regardless of success, set "hooks" to "PostSync,SyncFail".
#      #hooks:
#
#      # Sync waves are used to define an order in which resources are applied
#      # within a sync phase. Sync waves are configured using integers in
#      # ascending order, where resources with lower-value sync waves are
#      # applied first and resources with higher-value sync waves are applied
#      # last. The default sync wave used for all resources is "0".
#      #
#      # Here is an example illustrating ordering resources with sync waves:
#      #
#      #  -2+: Evaluated first. Good for ConfigMap, ExternalSecret,
#      #       ServiceAccount, or any other resources that are necessary
#      #       to successfully apply resources in later sync waves.
#      #
#      #   -1: Evaluated next. Good for jobs that need to be executed before
#      #       other resources in the chart (eg. database migrations).
#      #
#      #    0: Evaluated next. This is where all resources in the chart are
#      #       applied unless otherwise specified.
#      #
#      #   1+: Evaluated last. Resources in this sync wave are applied after
#      #       everything else in the chart is applied successfully. This can be
#      #       useful for things like jobs that toggle off maintenance mode.
#      #
#      # Sync waves can be used in conjunction with resource hooks.
#      #syncWave:
#    containers:
#      - # containers have names, too
#        name: unset
#        #
#        # Where to read the container image from. Will end up as {{ .image }}:{{ .tag }}
#        #
#        image: some-image
#        tag: some-image-tag
#
#        # Command to pass into the container as its entrypoint. This should be
#        # specified as a list of strings.
#        command: []
#
#        # Arguments to pass to a container. This should be specified as a list
#        # of strings.
#        args: []
#
#        # Expose environment variables directly into the container. This will
#        # override duplicate values mounted via ConfigMaps or secrets in the
#        # envFrom section.
#        env:
#          - name: KEY
#            value: "value"
#
#        #
#        # mount ConfigMaps or Secrets to container env
#        #
#        envFrom:
#          - configMapRef:
#              name: some-configmap
#
#          - secretRef:
#              name: some-secret
#
#        #
#        # Containers shouldn't be running with elevated privileges. This section
#        # defines a UID & GID the container should run with.
#        #
#        securityContext:
#          user: 10001
#          group: 10001
#
#        #
#        # Container resources. k8s spawns new containers only when enough room is left
#        # to match the defined requests here. This helps to scale k8s nodes efficiently.
#        # limits define the upper boundary of resources a container can consume. This can
#        # be more than requests of course, and competing resource usage on nodes (so don't
#        # set this too high).
#        # If resources == limits, k8s is asked to run Pods with QoS class of "Guaranteed",
#        # this effectively means reserving the specified resources explicitly for the container
#        # only, might be useful in some high performance workload scenarios.
#        #
#        resources:
#          requests:
#            cpu: 1000m
#            memory: 2Gi
#
#          limits:
#            cpu: 2000m
#            memory: 4Gi
#
#        #
#        # List of ports that the resulting Pod will be reachable at. Map ports to actual container ports.
#        #
#        ports:
#          - name: app
#            containerPort: 8000
#
#        #
#        # Define a method to poll the container to determine if it is still "live". If this probe fails,
#        # k8s will try to restart the container. livenessProbe should primarily prevent long running pods
#        # from transitioning to broken states.
#        #
#        livenessProbe:
#          httpGet:
#            path: /__heartbeat__
#            port: unset
#
#        #
#        # Define a method to poll the container to determine if it is "ready to serve traffic". If this
#        # probe fails, container will not receive traffic through k8s services. E.g. during long startup
#        # times, you don't want to send traffic to a pod, yet. Similarly, if e.g. dependent services on
#        # other ports fail their readiness, this could also be used to not serve any traffic, but keep
#        # the pod running, for example.
#        #
#        readinessProbe:
#          httpGet:
#            path: /__lbheartbeat__
#            port: unset
#
#    #
#    # Enable or disable NGINX for the deployment. If enabled, an NGINX
#    # container will be deployed to the pod alongside the application
#    # container. You can also specify a custom image and/or custom
#    # ConfigMap to use for the container.
#    #
#    # NGINX is enabled by default.
#    #
#    nginx:
#      enabled: true
#      image: unset
#      configMap: unset
#
#    #
#    # By default, no containers should run as root. The few exceptions to
#    # this rule can configure this by setting "runAsNonRoot" to "false".
#    #
#    # Note: The webservices-high and dataservices-high Kubernetes clusters
#    # will not allow you to deploy containers using the root user.
#    #
#    # The default value is "true".
#    #
#    securityContext:
#      runAsNonRoot: true
#
#    #
#    # If your pod should run using a specific Kubernetes service account,
#    # specify it here.
#    #
#    serviceAccount:
#

#
# PodMonitorings
#
# A dictionary of podMonitoring definitions. A PodMonotoring resource has a
# name and a list of endpoints to target for querying by GMP (Google managed
# Prometheus).
#
# Each podMonitoring should be a dictionary where the key is the name of the
# podMonitoring and the value is its configuration.
#
podMonitorings: {}
#  name:
#    endpoints:
#      - port: app
#        scheme: http
#        interval: 30s
#        path: /metrics

#
# HorizontalPodAutoscalers
#
# A dictionary of HorizontalPodAutoscaler (HPA) definitions. HPAs have a name,
# should set min & max replica sizes, have a scale target reference and, of
# course, a list of metrics to scale upon.
#
# Each HPA should be a dictionary where the key is the name of the
# podMonitoring and the value is its configuration.
#
hpas: {}
#  name:
#    minReplicas: 2
#    maxReplicas: 10
#    scaleTargetRef:
#      apiVersion: apps/v1
#      kind: Deployment
#      name: deployment-to-target
#
#    metrics:
#      - type: Resource
#        resource:
#          name: cpu
#          target:
#            type: Utilization
#            averageUtilization: 80
#
#      - type: Resource
#        resource:
#          name: memory
#          target:
#            type: Utilization
#            averageUtilization: 80
