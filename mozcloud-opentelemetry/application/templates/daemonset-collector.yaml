apiVersion: opentelemetry.io/v1beta1
kind: OpenTelemetryCollector
metadata:
  name: {{ include "mozcloud-opentelemetry.name" . }}-daemonset
  namespace: {{ .Release.Namespace }}
spec:
  {{- if .Values.serviceAccount.create }}
  serviceAccount: {{ .Values.serviceAccount.name }}
  {{- end }}
  mode: daemonset
  terminationGracePeriodSeconds: 600
  hostNetwork: true
  {{- with .Values.collectors.daemonset.securityContext }}
  securityContext: {{ toYaml . | nindent 4 }}
  {{- end }}
  {{- with .Values.collectors.daemonset.resources }}
  resources: {{ toYaml . | nindent 4 }}
  {{- end }}
  env:
  - name: POD_NAMESPACE
    valueFrom:
      fieldRef:
        fieldPath: metadata.namespace
  - name: POD_NAME
    valueFrom:
      fieldRef:
        fieldPath: metadata.name
  - name: POD_IP
    valueFrom:
      fieldRef:
        fieldPath: status.podIP
  - name: KUBE_NODE_NAME
    valueFrom:
      fieldRef:
        apiVersion: v1
        fieldPath: spec.nodeName
  config:
    receivers:
      otlp:
        protocols:
          grpc: {}
          http: {}

      statsd:
        endpoint: ${env:POD_IP}:8125
        aggregation_interval: 30s
        enable_metric_type: true
        enable_simple_tags: true
        is_monotonic_counter: true
        enable_ip_only_aggregation: true

    processors:
      # This processor ensures the start time is set for Prometheus metrics. This must be set in the pipeline before the k8sattributes processor, if used.
      metricstarttime:
        strategy: subtract_initial_point

      k8sattributes:
        otel_annotations: true
        filter:
          node_from_env_var: KUBE_NODE_NAME
        extract:
          metadata:
          - k8s.namespace.name
          - k8s.deployment.name
          - k8s.statefulset.name
          - k8s.daemonset.name
          - k8s.cronjob.name
          - k8s.job.name
          - k8s.replicaset.name
          - k8s.pod.name
          - k8s.pod.uid
        passthrough: false
        pod_association:
        - sources:
          - from: resource_attribute
            name: k8s.pod.ip
        - sources:
          - from: resource_attribute
            name: k8s.pod.uid
        - sources:
          - from: connection

      resourcedetection:
        detectors: [env, gcp]
        timeout: 10s
        override: false

      filter:
        error_mode: ignore
        traces:
          span:
            - attributes["http.route"] == "/__lbheartbeat__"
            - 'IsMatch(name, ".*__lbheartbeat__.*")'

      memory_limiter:
        # drop metrics if memory usage gets too high
        check_interval: 1s
        limit_percentage: 65
        spike_limit_percentage: 20

    exporters:
      debug:
        verbosity: detailed

      otlp:
        endpoint: {{ printf "%s:%s" .Values.collectors.gateway.endpoints.otlp.endpoint .Values.collectors.gateway.endpoints.otlp.port | quote }}
        tls:
          insecure: true

      loadbalancing/metrics-otlp:
        routing_key: streamID
        timeout: 10s
        retry_on_failure:
          enabled: true
          initial_interval: 5s
          max_interval: 30s
          max_elapsed_time: 300s
        protocol:
          otlp:
            tls:
              insecure: true
        resolver:
          dns:
            hostname: {{ .Values.collectors.gateway.endpoints.headless.endpoint }}
            port: {{ .Values.collectors.gateway.endpoints.headless.port | quote }}

      loadbalancing/traces-otlp:
        routing_key: traceID
        timeout: 10s
        retry_on_failure:
          enabled: true
          initial_interval: 5s
          max_interval: 30s
          max_elapsed_time: 300s
        protocol:
          otlp:
            tls:
              insecure: true
        resolver:
          dns:
            hostname: {{ .Values.collectors.gateway.endpoints.headless.endpoint }}
            port: {{ .Values.collectors.gateway.endpoints.headless.port | quote }}

    extensions:
      health_check:
        endpoint: ${env:POD_IP}:13133

      googleclientauth: {}

    service:
      extensions:
      - health_check
      - googleclientauth
      pipelines:
        metrics:
          receivers:
          - otlp
          - statsd
          processors:
          - metricstarttime
          - k8sattributes
          - memory_limiter
          - resourcedetection
          exporters:
          - loadbalancing/metrics-otlp
        traces:
          receivers:
          - otlp
          processors:
          - k8sattributes
          - memory_limiter
          - filter
          - resourcedetection
          exporters:
          - loadbalancing/traces-otlp
      telemetry:
        logs:
          encoding: json

        # k8sattributes processor doesn't work when using host networking so we
        # set some attributes by hand for use with telemetry.metrics.readers
        resource:
          k8s.daemonset.name: {{ include "mozcloud-opentelemetry.name" . }}-daemonset-collector
          k8s.pod.name: ${POD_NAME}
          namespace: ${POD_NAMESPACE}

        metrics:
          readers:
            - periodic:
                exporter:
                  otlp:
                    protocol: http/protobuf
                    endpoint: {{ printf "http://%s:%s" .Values.collectors.gateway.endpoints.otlp.endpoint .Values.collectors.gateway.endpoints.otlp.collectorMetricsPort | quote }}
